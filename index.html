<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SkyPredict Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2980, #26d0ce);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .tagline {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .card h2 i {
            margin-right: 10px;
        }

        .media-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .video-container, .canvas-container {
            position: relative;
            width: 100%;
            height: 240px;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }

        video, canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .obstruction-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        .obstruction-overlay.hidden {
            display: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            background: linear-gradient(135deg, #4776E6, #8E54E9);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #4776E6, #8E54E9);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .result-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .result-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .result-card h3 i {
            margin-right: 10px;
        }

        .prediction {
            font-size: 1.8rem;
            font-weight: bold;
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
        }

        .rain-likely {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
        }

        .rain-possible {
            background: linear-gradient(135deg, #f7971e, #ffd200);
        }

        .no-rain {
            background: linear-gradient(135deg, #00b09b, #96c93d);
        }

        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .metric-value {
            font-weight: bold;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: linear-gradient(135deg, #4776E6, #8E54E9);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .confidence-high {
            background: linear-gradient(135deg, #00b09b, #96c93d);
        }

        .confidence-medium {
            background: linear-gradient(135deg, #f7971e, #ffd200);
        }

        .confidence-low {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4b2b;
        }

        .status-dot.active {
            background: #00b09b;
        }
        
        .image-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>SkyPredict</h1>
            <p class="tagline">Real-time rain prediction using your camera and environmental data</p>
        </header>

        <div class="dashboard">
            <div class="card">
                <h2><i>üìπ</i> Camera Feed</h2>
                <div class="media-container">
                    <div class="video-container">
                        <video id="video" autoplay playsinline></video>
                        <canvas id="frozenCanvas" style="display: none;"></canvas>
                        <div class="image-label" id="topLabel" style="display: none;">Frozen Image</div>
                        <div class="obstruction-overlay hidden" id="obstructionOverlay">
                            <i style="font-size: 3rem; margin-bottom: 15px;">‚ö†Ô∏è</i>
                            <p id="obstructionMessage">Obstruction detected</p>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="canvas"></canvas>
                        <div class="image-label" id="bottomLabel" style="display: none;">Negative Image</div>
                    </div>
                </div>
                <div class="controls">
                    <button id="startBtn">
                        <i>‚ñ∂Ô∏è</i> Start Camera
                    </button>
                    <button id="captureBtn" disabled>
                        <i>üåßÔ∏è</i> Analyze Sky
                    </button>
                    <div class="toggle-container">
                        <label for="maskToggle">Sky Masking</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="maskToggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                <div class="status">
                    <div class="status-dot" id="cameraStatus"></div>
                    <span id="cameraStatusText">Camera not active</span>
                </div>
            </div>

            <div class="card">
                <h2><i>üìä</i> Prediction Results</h2>
                <div id="output">
                    <div class="prediction" id="prediction">‚Äî</div>
                    
                    <div class="metric">
                        <span>Rain Probability</span>
                        <span class="metric-value" id="rainProbability">‚Äî</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress" id="rainProbabilityBar" style="width: 0%"></div>
                    </div>
                    
                    <div class="metric">
                        <span>Estimated Rain Rate</span>
                        <span class="metric-value" id="rainRate">‚Äî mm/hr</span>
                    </div>
                    
                    <div class="metric">
                        <span>Cloudiness</span>
                        <span class="metric-value" id="cloudiness">‚Äî</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress" id="cloudinessBar" style="width: 0%"></div>
                    </div>
                    
                    <div class="metric">
                        <span>Sky Clarity</span>
                        <span class="metric-value" id="skyClarity">‚Äî</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress" id="skyClarityBar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="status">
                    <div class="status-dot" id="analysisStatus"></div>
                    <span id="analysisStatusText">Ready for analysis</span>
                </div>
            </div>
        </div>

        <div class="results">
            <div class="result-card">
                <h3><i>üåç</i> Environmental Data</h3>
                <div class="metric">
                    <span>Humidity</span>
                    <span class="metric-value" id="humidity">‚Äî%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="humidityBar" style="width: 0%"></div>
                </div>
                
                <div class="metric">
                    <span>Cloud Cover</span>
                    <span class="metric-value" id="cloudCover">‚Äî%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="cloudCoverBar" style="width: 0%"></div>
                </div>
                
                <div class="metric">
                    <span>Temperature</span>
                    <span class="metric-value" id="temperature">‚Äî¬∞C</span>
                </div>
            </div>
            
            <div class="result-card">
                <h3><i>üìà</i> Analysis Metrics</h3>
                <div class="metric">
                    <span>Edge Density</span>
                    <span class="metric-value" id="edgeDensity">‚Äî</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="edgeDensityBar" style="width: 0%"></div>
                </div>
                
                <div class="metric">
                    <span>Blue Channel</span>
                    <span class="metric-value" id="blueChannel">‚Äî</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="blueChannelBar" style="width: 0%"></div>
                </div>
                
                <div class="metric">
                    <span>Processing Time</span>
                    <span class="metric-value" id="processingTime">‚Äî ms</span>
                </div>
            </div>
            
            <div class="result-card">
                <h3><i>üîÆ</i> Forecast</h3>
                <div class="metric">
                    <span>Next 1 hour</span>
                    <span class="metric-value" id="next1Hour">‚Äî</span>
                </div>
                <div class="metric">
                    <span>Next 3 hours</span>
                    <span class="metric-value" id="next3Hours">‚Äî</span>
                </div>
                <div class="metric">
                    <span>Next 6 hours</span>
                    <span class="metric-value" id="next6Hours">‚Äî</span>
                </div>
                <div class="metric">
                    <span>Confidence</span>
                    <span class="metric-value" id="confidence">‚Äî</span>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="confidenceBar" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <footer>
            <p>SkyPredict Demo | Real-time rain prediction using computer vision and environmental data fusion</p>
        </footer>
    </div>

    <script>
    // DOM Elements
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const frozenCanvas = document.getElementById('frozenCanvas');
    const startBtn = document.getElementById('startBtn');
    const captureBtn = document.getElementById('captureBtn');
    const maskToggle = document.getElementById('maskToggle');
    const cameraStatus = document.getElementById('cameraStatus');
    const cameraStatusText = document.getElementById('cameraStatusText');
    const analysisStatus = document.getElementById('analysisStatus');
    const analysisStatusText = document.getElementById('analysisStatusText');
    const obstructionOverlay = document.getElementById('obstructionOverlay');
    const obstructionMessage = document.getElementById('obstructionMessage');
    const topLabel = document.getElementById('topLabel');
    const bottomLabel = document.getElementById('bottomLabel');
    
    // Result elements
    const predictionEl = document.getElementById('prediction');
    const rainProbabilityEl = document.getElementById('rainProbability');
    const rainProbabilityBar = document.getElementById('rainProbabilityBar');
    const rainRateEl = document.getElementById('rainRate');
    const cloudinessEl = document.getElementById('cloudiness');
    const cloudinessBar = document.getElementById('cloudinessBar');
    const skyClarityEl = document.getElementById('skyClarity');
    const skyClarityBar = document.getElementById('skyClarityBar');
    const humidityEl = document.getElementById('humidity');
    const humidityBar = document.getElementById('humidityBar');
    const cloudCoverEl = document.getElementById('cloudCover');
    const cloudCoverBar = document.getElementById('cloudCoverBar');
    const temperatureEl = document.getElementById('temperature');
    const edgeDensityEl = document.getElementById('edgeDensity');
    const edgeDensityBar = document.getElementById('edgeDensityBar');
    const blueChannelEl = document.getElementById('blueChannel');
    const blueChannelBar = document.getElementById('blueChannelBar');
    const processingTimeEl = document.getElementById('processingTime');
    const next1HourEl = document.getElementById('next1Hour');
    const next3HoursEl = document.getElementById('next3Hours');
    const next6HoursEl = document.getElementById('next6Hours');
    const confidenceEl = document.getElementById('confidence');
    const confidenceBar = document.getElementById('confidenceBar');

    // Canvas context
    const ctx = canvas.getContext('2d');
    const frozenCtx = frozenCanvas.getContext('2d');
    canvas.width = 640;
    canvas.height = 480;
    frozenCanvas.width = 640;
    frozenCanvas.height = 480;

    // State variables
    let isCameraActive = false;
    let stream = null;
    let analysisInterval = null;
    let obstructionDetected = false;
    let obstructionType = null;
    let faceModel = null;
    let modelsLoaded = false;
    let detectionInterval = null;
    let isAnalyzing = false;
    let isFrozen = false;

    // Load face detection model
    async function loadFaceModel() {
        try {
            console.log('Loading face detection model...');
            // Load BlazeFace model for fast face detection
            faceModel = await blazeface.load();
            modelsLoaded = true;
            console.log('Face detection model loaded successfully');
        } catch (error) {
            console.error('Error loading face detection model:', error);
            modelsLoaded = false;
        }
    }

    // Real face detection function
    async function detectFaces() {
        if (!modelsLoaded || !isCameraActive) return false;
        
        try {
            const predictions = await faceModel.estimateFaces(video, false);
            return predictions.length > 0;
        } catch (error) {
            console.error('Error in face detection:', error);
            return false;
        }
    }

    // Simple building detection using image analysis
    function detectBuildings() {
        if (!isCameraActive) return false;
        
        try {
            // Draw current video frame to canvas for analysis
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Analyze the image for building-like features
            // Buildings typically have straight edges and rectangular shapes
            let edgeCount = 0;
            let buildingLikelihood = 0;
            
            // Simple edge detection in the lower part of the image (where buildings would be)
            for (let y = canvas.height * 0.4; y < canvas.height - 1; y++) {
                for (let x = 1; x < canvas.width - 1; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const nextIdx = (y * canvas.width + (x + 1)) * 4;
                    
                    // Check for significant color changes (edges)
                    const diff = Math.abs(data[idx] - data[nextIdx]) + 
                                 Math.abs(data[idx + 1] - data[nextIdx + 1]) + 
                                 Math.abs(data[idx + 2] - data[nextIdx + 2]);
                    
                    if (diff > 50) { // Threshold for edge detection
                        edgeCount++;
                    }
                }
            }
            
            // Calculate building likelihood based on edge density
            const analysisArea = (canvas.width - 2) * (canvas.height * 0.6 - 1);
            buildingLikelihood = (edgeCount / analysisArea) * 1000;
            
            return buildingLikelihood > 15; // Threshold for building detection
        } catch (error) {
            console.error('Error in building detection:', error);
            return false;
        }
    }

    // Main obstruction detection function
    async function checkForObstructions() {
        if (!isCameraActive || isAnalyzing) return;
        
        // Reset obstruction state
        obstructionDetected = false;
        obstructionType = null;
        
        // First check for faces (highest priority)
        const facesDetected = await detectFaces();
        if (facesDetected) {
            obstructionDetected = true;
            obstructionType = 'face';
            return;
        }
        
        // If no faces, check for buildings
        const buildingsDetected = detectBuildings();
        if (buildingsDetected) {
            obstructionDetected = true;
            obstructionType = 'building';
            return;
        }
        
        // If neither, view is clear
        obstructionDetected = false;
        obstructionType = null;
    }

    // Update UI based on obstruction status
    function updateObstructionUI() {
        if (obstructionDetected) {
            // Show obstruction overlay
            obstructionOverlay.classList.remove('hidden');
            
            // Set appropriate message
            if (obstructionType === 'face') {
                obstructionMessage.textContent = 'Human faces detected, blocking sky view';
            } else if (obstructionType === 'building') {
                obstructionMessage.textContent = 'Avoid Obstructions for analysis';
            }
            
            // Disable analyze button
            captureBtn.disabled = true;
            
            // Update status
            cameraStatus.classList.remove('active');
            cameraStatusText.textContent = 'Obstruction detected';
        } else {
            // Hide obstruction overlay
            obstructionOverlay.classList.add('hidden');
            
            // Enable analyze button
            captureBtn.disabled = false;
            
            // Update status
            cameraStatus.classList.add('active');
            cameraStatusText.textContent = 'Camera active';
        }
    }

    // Start obstruction detection
    function startObstructionDetection() {
        // Check for obstructions every 2 seconds
        detectionInterval = setInterval(async () => {
            if (!isCameraActive || isAnalyzing) return;
            
            await checkForObstructions();
            updateObstructionUI();
        }, 200);
    }

    // Start webcam
    async function startWebcam() {
        try {
            // Load face detection model on first use
            if (!faceModel) {
                await loadFaceModel();
            }
            
            stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    facingMode: "environment",
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            
            video.srcObject = stream;
            await video.play();
            
            isCameraActive = true;
            isAnalyzing = false;
            isFrozen = false;
            cameraStatus.classList.add('active');
            cameraStatusText.textContent = 'Camera active';
            startBtn.innerHTML = '<i>‚èπÔ∏è</i> Stop Camera';
            captureBtn.disabled = false;
            
            // Show video and hide frozen canvas
            video.style.display = 'block';
            frozenCanvas.style.display = 'none';
            topLabel.style.display = 'none';
            bottomLabel.style.display = 'none';
            
            // Start drawing video to canvas
            drawVideoToCanvas();
            
            // Start obstruction detection
            startObstructionDetection();
            
        } catch (err) {
            console.error("Error accessing camera:", err);
            alert("Could not access camera: " + err.message);
        }
    }

    // Stop webcam
    function stopWebcam() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }
        
        if (detectionInterval) {
            clearInterval(detectionInterval);
            detectionInterval = null;
        }
        
        isCameraActive = false;
        cameraStatus.classList.remove('active');
        cameraStatusText.textContent = 'Camera not active';
        startBtn.innerHTML = '<i>‚ñ∂Ô∏è</i> Start Camera';
        captureBtn.disabled = true;
        
        // Clear any active intervals
        if (analysisInterval) {
            clearInterval(analysisInterval);
            analysisInterval = null;
        }
        
        // Reset obstruction detection
        obstructionDetected = false;
        obstructionType = null;
        obstructionOverlay.classList.add('hidden');
        
        // If we're frozen, keep the frozen images visible
        if (!isFrozen) {
            // If not frozen, clear the canvases
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            frozenCtx.clearRect(0, 0, frozenCanvas.width, frozenCanvas.height);
            
            // Show video and hide frozen canvas
            video.style.display = 'block';
            frozenCanvas.style.display = 'none';
            topLabel.style.display = 'none';
            bottomLabel.style.display = 'none';
        }
    }

    // Draw video to canvas
    function drawVideoToCanvas() {
        if (!isCameraActive || isFrozen) return;
        
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Apply sky masking if enabled
        if (maskToggle.checked && !isFrozen) {
            applySkyMasking();
        }
        
        requestAnimationFrame(drawVideoToCanvas);
    }

    // Apply simple sky masking (upper portion of the image)
    function applySkyMasking() {
        // Create a gradient mask for the sky region
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height * 0.6);
        
        // Add text label
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.fillText('Sky Analysis Region', 10, 30);
    }

    // Create negative image from source canvas
    function createNegativeImage(sourceCanvas, targetCanvas) {
        const sourceCtx = sourceCanvas.getContext('2d');
        const targetCtx = targetCanvas.getContext('2d');
        
        // Copy the source image to target
        targetCtx.drawImage(sourceCanvas, 0, 0, targetCanvas.width, targetCanvas.height);
        
        // Get image data
        const imageData = targetCtx.getImageData(0, 0, targetCanvas.width, targetCanvas.height);
        const data = imageData.data;
        
        // Invert each pixel (negative effect)
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];     // Red
            data[i + 1] = 255 - data[i + 1]; // Green
            data[i + 2] = 255 - data[i + 2]; // Blue
            // Alpha channel (data[i+3]) remains unchanged
        }
        
        // Put the modified image data back
        targetCtx.putImageData(imageData, 0, 0);
    }

    // Analyze the current frame
    function analyzeFrame() {
        if (!isCameraActive || obstructionDetected || isAnalyzing) return;
        
        // --- THIS IS THE FIX ---
        // Stop the obstruction detection interval to prevent it from
        // overwriting the canvas while the image is frozen.
        if (detectionInterval) {
            clearInterval(detectionInterval);
            detectionInterval = null;
        }

        isAnalyzing = true;
        isFrozen = true;
        const startTime = performance.now();
        
        // Update status
        analysisStatusText.innerHTML = '<span class="loading"></span> Analyzing...';
        
        // Freeze the current frame in both containers
        frozenCtx.drawImage(video, 0, 0, frozenCanvas.width, frozenCanvas.height);
        
        // Show frozen canvas and hide video
        video.style.display = 'none';
        frozenCanvas.style.display = 'block';
        topLabel.style.display = 'block';
        
        // Create negative image in the second canvas
        createNegativeImage(frozenCanvas, canvas);
        bottomLabel.style.display = 'block';
        
        // Simulate analysis (in a real app, this would process the image)
        setTimeout(() => {
            // Generate simulated results
            const cloudiness = Math.random() * 100;
            const edgeDensity = Math.random() * 100;
            const blueChannel = Math.random() * 100;
            const humidity = 30 + Math.random() * 70;
            const cloudCover = Math.random() * 100;
            const temperature = 15 + Math.random() * 25;
            
            // Calculate rain probability based on factors
            const rainProbability = Math.min(100, 
                cloudiness * 0.4 + 
                edgeDensity * 0.3 + 
                humidity * 0.2 + 
                cloudCover * 0.1
            );
            
            // Determine prediction
            let prediction, predictionClass;
            if (rainProbability > 70) {
                prediction = "Rain Likely";
                predictionClass = "rain-likely";
            } else if (rainProbability > 30) {
                prediction = "Rain Possible";
                predictionClass = "rain-possible";
            } else {
                prediction = "No Rain Expected";
                predictionClass = "no-rain";
            }
            
            // Estimate rain rate
            const rainRate = (rainProbability / 100 * 10).toFixed(1);
            
            // Calculate confidence
            const confidence = 70 + Math.random() * 25;
            
            // Update UI with results
            updateResults({
                prediction,
                predictionClass,
                rainProbability: rainProbability.toFixed(1),
                rainRate,
                cloudiness: cloudiness.toFixed(1),
                skyClarity: (100 - cloudiness).toFixed(1),
                humidity: humidity.toFixed(1),
                cloudCover: cloudCover.toFixed(1),
                temperature: temperature.toFixed(1),
                edgeDensity: edgeDensity.toFixed(1),
                blueChannel: blueChannel.toFixed(1),
                processingTime: (performance.now() - startTime).toFixed(0),
                confidence: confidence.toFixed(1)
            });
            
            // Update status
            analysisStatus.classList.add('active');
            analysisStatusText.textContent = 'Analysis complete';
            
            isAnalyzing = false;
        }, 800);
    }

    // Update UI with analysis results
    function updateResults(results) {
        // Update prediction
        predictionEl.textContent = results.prediction;
        predictionEl.className = `prediction ${results.predictionClass}`;
        
        // Update metrics
        rainProbabilityEl.textContent = `${results.rainProbability}%`;
        rainProbabilityBar.style.width = `${results.rainProbability}%`;
        
        rainRateEl.textContent = `${results.rainRate} mm/hr`;
        
        cloudinessEl.textContent = `${results.cloudiness}%`;
        cloudinessBar.style.width = `${results.cloudiness}%`;
        
        skyClarityEl.textContent = `${results.skyClarity}%`;
        skyClarityBar.style.width = `${results.skyClarity}%`;
        
        humidityEl.textContent = `${results.humidity}%`;
        humidityBar.style.width = `${results.humidity}%`;
        
        cloudCoverEl.textContent = `${results.cloudCover}%`;
        cloudCoverBar.style.width = `${results.cloudCover}%`;
        
        temperatureEl.textContent = `${results.temperature}¬∞C`;
        
        edgeDensityEl.textContent = `${results.edgeDensity}%`;
        edgeDensityBar.style.width = `${results.edgeDensity}%`;
        
        blueChannelEl.textContent = `${results.blueChannel}%`;
        blueChannelBar.style.width = `${results.blueChannel}%`;
        
        processingTimeEl.textContent = `${results.processingTime} ms`;
        
        // Update forecast
        next1HourEl.textContent = results.rainProbability > 50 ? "Rain likely" : "Clear";
        next3HoursEl.textContent = results.rainProbability > 40 ? "Possible rain" : "Mostly clear";
        next6HoursEl.textContent = results.rainProbability > 30 ? "Uncertain" : "Clear";
        
        confidenceEl.textContent = `${results.confidence}%`;
        confidenceBar.style.width = `${results.confidence}%`;
        
        // Set confidence bar color
        if (results.confidence > 80) {
            confidenceBar.className = "progress confidence-high";
        } else if (results.confidence > 60) {
            confidenceBar.className = "progress confidence-medium";
        } else {
            confidenceBar.className = "progress confidence-low";
        }
    }

    // Event listeners
    startBtn.addEventListener('click', () => {
        if (isCameraActive) {
            stopWebcam();
        } else {
            startWebcam();
        }
    });

    captureBtn.addEventListener('click', () => {
        analyzeFrame();
    });

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        // Set initial state
        cameraStatusText.textContent = 'Camera not active';
        analysisStatusText.textContent = 'Ready for analysis';
        
        // Pre-load face detection model
        loadFaceModel();
    });
</script>
</body>
</html>
